<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[M.Tech CSE]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>M.Tech CSE</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 14 Jun 2024 10:07:41 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 14 Jun 2024 10:07:36 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Document Needed for Physical Document Verification]]></title><description><![CDATA[ 
 <br>Note:<br>
<br>All Document with Original and Photo copy at Venu Time
<br>
<br>Copy of the online application form
<br>Copy of the seat allotment letter.
<br>Copy of Admission fee payment receipt
<br>The Migration Certificate or College Leaving Certificate
<br>Photo ID (Aadhaar/PAN/DL etc) and Proof of age (Plus 2 certificate/Aadhaar/Matriculation certificate, etc.)
<br>4 passport size and 10 stamp size colour photographs.
<br>B.Tech Degree
<br>B.tech Mark sheets of All semester
<br>Caste Certificate
<br>12th Mark Sheet
<br>10th Mark sheet
<br>class awarded Certificate
<br>GATE Score card
<br>Medical Fitness Certificate (as per Annexure II)

<br>Format: as per Annexure II
<br>Signed By: the chief medical officer (CMO) or equivalent of a government hospital
<br>colour blindness/uniocularity


]]></description><link>before-admission/document-needed-for-physical-document-verification.html</link><guid isPermaLink="false">Before Admission/Document Needed for Physical Document Verification.md</guid><pubDate>Sat, 08 Jun 2024 09:02:29 GMT</pubDate></item><item><title><![CDATA[1. The Surprising Power of Atomic Habits]]></title><description><![CDATA[ 
 <br><img alt="Book Reading/Atomic Habits/media/media/(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018).webp" src="book-reading/atomic-habits/media/media/(b07d23cfgr)-james-clear-atomic-habits-random-house-business-books-(2018).webp"><br><a data-tooltip-position="top" aria-label="(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018).pdf > page=19&amp;rect=167,379,425,466" data-href="(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018).pdf#page=19&amp;rect=167,379,425,466" href="book-reading/atomic-habits/media/(b07d23cfgr)-james-clear-atomic-habits-random-house-business-books-(2018).pdf#page=19&amp;rect=167,379,425,466" class="internal-link" target="_self" rel="noopener">(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018), p.19</a><br><a data-tooltip-position="top" aria-label="(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018).pdf > page=20&amp;selection=18,15,19,22" data-href="(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018).pdf#page=20&amp;selection=18,15,19,22" href="book-reading/atomic-habits/media/(b07d23cfgr)-james-clear-atomic-habits-random-house-business-books-(2018).pdf#page=20&amp;selection=18,15,19,22" class="internal-link" target="_self" rel="noopener">(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018), p.20</a>

the slow pace of transformation also makes it easy to let a bad habit slide.

<br><a data-tooltip-position="top" aria-label="(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018).pdf > page=21&amp;selection=16,11,17,27" data-href="(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018).pdf#page=21&amp;selection=16,11,17,27" href="book-reading/atomic-habits/media/(b07d23cfgr)-james-clear-atomic-habits-random-house-business-books-(2018).pdf#page=21&amp;selection=16,11,17,27" class="internal-link" target="_self" rel="noopener">(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018), p.21</a>

a slight change in your daily habits can guide your life to a very different destination.

<br><a data-tooltip-position="top" aria-label="(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018).pdf > page=21&amp;selection=20,53,21,63" data-href="(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018).pdf#page=21&amp;selection=20,53,21,63" href="book-reading/atomic-habits/media/(b07d23cfgr)-james-clear-atomic-habits-random-house-business-books-(2018).pdf#page=21&amp;selection=20,53,21,63" class="internal-link" target="_self" rel="noopener">(B07D23CFGR) James Clear - Atomic Habits-Random House Business Books (2018), p.21</a>

Success is the product of daily habits—not once-in-a-lifetime transformations.

]]></description><link>book-reading/atomic-habits/1.-the-surprising-power-of-atomic-habits.html</link><guid isPermaLink="false">Book Reading/Atomic Habits/1. The Surprising Power of Atomic Habits.md</guid><pubDate>Tue, 11 Jun 2024 06:19:04 GMT</pubDate><enclosure url="book-reading/atomic-habits/media/media/(b07d23cfgr)-james-clear-atomic-habits-random-house-business-books-(2018).webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;book-reading/atomic-habits/media/media/(b07d23cfgr)-james-clear-atomic-habits-random-house-business-books-(2018).webp&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Atomic Habits Introduction]]></title><description><![CDATA[ 
 <br>]]></description><link>book-reading/atomic-habits/atomic-habits-introduction.html</link><guid isPermaLink="false">Book Reading/Atomic Habits/Atomic Habits Introduction.md</guid><pubDate>Tue, 11 Jun 2024 05:51:30 GMT</pubDate></item><item><title><![CDATA[At Most To Equal]]></title><description><![CDATA[ 
 <br>Exactly k times = At Most k times - At Most k - 1 times.<br>Problems<br>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/binary-subarrays-with-sum/" rel="noopener" class="external-link" href="https://leetcode.com/problems/binary-subarrays-with-sum/" target="_blank">930. Binary Subarrays With Sum (Medium)</a><br>

<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/subarrays-with-k-different-integers/" rel="noopener" class="external-link" href="https://leetcode.com/problems/subarrays-with-k-different-integers/" target="_blank">992. Subarrays with K Different Integers (Hard)</a><br>

<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/count-number-of-nice-subarrays/" rel="noopener" class="external-link" href="https://leetcode.com/problems/count-number-of-nice-subarrays/" target="_blank">1248. Count Number of Nice Subarrays (Medium)</a>
]]></description><link>codepattern/blog/code/at-most-to-equal.html</link><guid isPermaLink="false">CodePattern/blog/code/At Most To Equal.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[C++ Maximum Sliding Window Cheatsheet Template!]]></title><description><![CDATA[ 
 <br><br>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1499836/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" rel="noopener" class="external-link" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1499836/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" target="_blank">3. Longest Substring Without Repeating Characters</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/1499839/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" rel="noopener" class="external-link" href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/1499839/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" target="_blank">159. Longest Substring with At Most Two Distinct Characters (Medium)</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/1499842/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" rel="noopener" class="external-link" href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/1499842/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" target="_blank">340. Longest Substring with At Most K Distinct Characters</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/longest-repeating-character-replacement/discuss/1499834/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" rel="noopener" class="external-link" href="https://leetcode.com/problems/longest-repeating-character-replacement/discuss/1499834/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" target="_blank">424. Longest Repeating Character Replacement</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1499844/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" rel="noopener" class="external-link" href="https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1499844/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" target="_blank">487. Max Consecutive Ones II</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/subarray-product-less-than-k/discuss/1501834/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" rel="noopener" class="external-link" href="https://leetcode.com/problems/subarray-product-less-than-k/discuss/1501834/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" target="_blank">713. Subarray Product Less Than K</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1504260/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" rel="noopener" class="external-link" href="https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1504260/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" target="_blank">1004. Max Consecutive Ones III</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/1529234/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" rel="noopener" class="external-link" href="https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/1529234/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" target="_blank">1208. Get Equal Substrings Within Budget (Medium)</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/1504267/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" rel="noopener" class="external-link" href="https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/1504267/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet)" target="_blank">1493. Longest Subarray of 1's After Deleting One Element</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/maximum-erasure-value/discuss/1504271/C%2B%2B-Sliding-Window-(%2BCheat-Sheet)" rel="noopener" class="external-link" href="https://leetcode.com/problems/maximum-erasure-value/discuss/1504271/C%2B%2B-Sliding-Window-(%2BCheat-Sheet)" target="_blank">1695. Maximum Erasure Value</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!" rel="noopener" class="external-link" href="https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!" target="_blank">1838. Frequency of the Most Frequent Element</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/discuss/1470857/C%2B%2B-Sliding-Window" rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/discuss/1470857/C%2B%2B-Sliding-Window" target="_blank">2009. Minimum Number of Operations to Make Array Continuous</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/maximize-the-confusion-of-an-exam/discuss/1499033/c-sliding-window-cheat-sheet" rel="noopener" class="external-link" href="https://leetcode.com/problems/maximize-the-confusion-of-an-exam/discuss/1499033/c-sliding-window-cheat-sheet" target="_blank">2024. Maximize the Confusion of an Exam</a>
<br>The following problems are also solvable using the shrinkable template with the&nbsp;<a data-tooltip-position="top" aria-label="https://leetcode.com/problems/count-vowel-substrings-of-a-string/discuss/1563765/c-on-time-sliding-window/1141941" rel="noopener" class="external-link" href="https://leetcode.com/problems/count-vowel-substrings-of-a-string/discuss/1563765/c-on-time-sliding-window/1141941" target="_blank">"At Most to Equal" trick</a><br>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/binary-subarrays-with-sum/discuss/1513935/C%2B%2B-Prefix-State-Map-or-Sliding-Window" rel="noopener" class="external-link" href="https://leetcode.com/problems/binary-subarrays-with-sum/discuss/1513935/C%2B%2B-Prefix-State-Map-or-Sliding-Window" target="_blank">930. Binary Subarrays With Sum (Medium)</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/1499830/C%2B%2B-Sliding-Window" rel="noopener" class="external-link" href="https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/1499830/C%2B%2B-Sliding-Window" target="_blank">992. Subarrays with K Different Integers</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/1515501/C%2B%2B-Prefix-State-Map-Two-Pointers-Sliding-Window" rel="noopener" class="external-link" href="https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/1515501/C%2B%2B-Prefix-State-Map-Two-Pointers-Sliding-Window" target="_blank">1248. Count Number of Nice Subarrays (Medium)</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/count-vowel-substrings-of-a-string/discuss/1563765/c-on-time-sliding-window/1141941" rel="noopener" class="external-link" href="https://leetcode.com/problems/count-vowel-substrings-of-a-string/discuss/1563765/c-on-time-sliding-window/1141941" target="_blank">2062. Count Vowel Substrings of a String (Easy)</a>
<br>Sliding Window<br><br><br><br>int i = 0, j = 0, ans = 0;
for (; j &lt; N; ++j) {
    // CODE: use A[j] to update state which might make the window invalid
    for (; invalid(); ++i) { // when invalid, keep shrinking the left edge until it's valid again
        // CODE: update state using A[i]
    }
    ans = max(ans, j - i + 1); // the window [i, j] is the maximum window we've found thus far
}
return ans;
Copy<br>Gemini
The provided code demonstrates the sliding window algorithm that iterates through an array using two pointers, i and j, to find the maximum window with a valid state. It follows a "shrinkable" approach, where the window can shrink as long as it remains valid.

<br>
Initialize Pointers and Maximum Length:

<br>i is the left edge of the sliding window, initially set to 0.
<br>j is the right edge of the sliding window, initially set to 0.
<br>ans stores the maximum length of a valid window found so far, initialized to 0.


<br>
Iterate and Check Validity:

<br>For each element A[j], check if the current window [i, j] is valid.
<br>If invalid:

<br>Increment i until the window becomes valid again, updating the state using A[i] as the left edge.




<br>
Update Maximum Length:

<br>After checking validity, calculate the length of the current window as j - i + 1.
<br>Update ans to be the maximum of its current value and the current window length.


<br>
Advance Right Pointer:

<br>Increment j to continue iterating and potentially expand the window.


<br>
Return Result:

<br>After iterating through the entire array, ans holds the maximum length of a valid window found during the process. This value is returned as the result.



In summary, this code efficiently finds the maximum window with a valid state in an array by shrinking the left edge as necessary while expanding the right edge.
<br>Essentially, we want to&nbsp;keep the window valid&nbsp;at the end of each outer&nbsp;for&nbsp;loop.<br>Solution for this question:<br>
<br>What should we use as the&nbsp;state? It should be the sum of numbers in the window
<br>How to determine&nbsp;invalid? The window is invalid if&nbsp;(j - i + 1) * A[j] - sum &gt; k.
<br>// OJ: https://leetcode.com/problems/frequency-of-the-most-frequent-element/
// Author: github.com/lzl124631x
// Time: O(NlogN)
// Space: O(1)
class Solution {
public:
    int maxFrequency(vector&lt;int&gt;&amp; A, int k) {
        sort(begin(A), end(A));
        long i = 0, N = A.size(), ans = 1, sum = 0;
        for (int j = 0; j &lt; N; ++j) {
            sum += A[j];
            while ((j - i + 1) * A[j] - sum &gt; k) sum -= A[i++];
            ans = max(ans, j - i + 1);
        }
        return ans;
    }
};
Copy<br>FAQ:<br>
<br>Why is the time complexity&nbsp;O(NlogN)?<br>
The sorting takes&nbsp;O(NlogN). The two pointer part only takes&nbsp;O(N)&nbsp;because both the pointers&nbsp;i&nbsp;and&nbsp;j&nbsp;traverse the array ONLY ONCE.<br>

<br>Why is&nbsp;(j - i + 1) * A[j] - sum &lt;= k&nbsp;valid?<br>
(j - i + 1)&nbsp;is the length of the window&nbsp;[i, j]. We want to increase all the numbers in the window to equal&nbsp;A[j], the number of operations needed is&nbsp;(j - i + 1) * A[j] - sum&nbsp;which should be&nbsp;&lt;= k. For example, assume the window is&nbsp;[1,2,3], increasing all the numbers to&nbsp;3&nbsp;will take&nbsp;3 * 3 - (1 + 2 + 3)&nbsp;operations.<br>

<br><br>int i = 0, j = 0;
for (; j &lt; N; ++j) {
    // CODE: use A[j] to update state which might make the window invalid
    if (invalid()) { // Increment the left edge ONLY when the window is invalid. In this way, the window GROWs when it's valid, and SHIFTs when it's invalid
        // CODE: update state using A[i]
        ++i;
    }
    // after `++j` in the for loop, this window `[i, j)` of length `j - i` MIGHT be valid.
}
return j - i; // There must be a maximum window of size `j - i`.
Copy<br>Essentially, we GROW the window when it's valid, and SHIFT the window when it's invalid.<br>Note that there is only a SINGLE&nbsp;for&nbsp;loop now!<br>Solution for this question:<br>// OJ: https://leetcode.com/problems/frequency-of-the-most-frequent-element/
// Author: github.com/lzl124631x
// Time: O(NlogN)
// Space: O(1)
class Solution {
public:
    int maxFrequency(vector&lt;int&gt;&amp; A, int k) {
        sort(begin(A), end(A));
        long i = 0, j = 0, N = A.size(), sum = 0;
        for (; j &lt; N; ++j) {
            sum += A[j];
            if ((j - i + 1) * A[j] - sum &gt; k) sum -= A[i++];
        }
        return j - i;
    }
};
Copy<br><br><br><br>
<br>What's&nbsp;state?&nbsp;cnt&nbsp;as the number of&nbsp;0s in the window.
<br>What's&nbsp;invalid?&nbsp;cnt &gt; 1&nbsp;is invalid.
<br>// OJ: https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
public:
    int longestSubarray(vector&lt;int&gt;&amp; A) {
        int i = 0, j = 0, N = A.size(), cnt = 0, ans = 0;
        for (; j &lt; N; ++j) {
            cnt += A[j] == 0;
            while (cnt &gt; 1) cnt -= A[i++] == 0;
            ans = max(ans, j - i); // note that the window is of size `j - i + 1`. We use `j - i` here because we need to delete a number.
        }
        return ans;
    }
};
Copy<br><br>// OJ: https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
public:
    int longestSubarray(vector&lt;int&gt;&amp; A) {
        int i = 0, j = 0, N = A.size(), cnt = 0;
        for (; j &lt; N; ++j) {
            cnt += A[j] == 0;
            if (cnt &gt; 1) cnt -= A[i++] == 0;
        }
        return j - i - 1;
    }
};
Copy<br><br><br>
<br>state:&nbsp;cnt[ch]&nbsp;is the number of occurrence of character&nbsp;ch&nbsp;in window.
<br>invalid:&nbsp;cnt[s[j]] &gt; 1&nbsp;is invalid.
<br>// OJ: https://leetcode.com/problems/longest-substring-without-repeating-characters/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int i = 0, j = 0, N = s.size(), ans = 0, cnt[128] = {};
        for (; j &lt; N; ++j) {
            cnt[s[j]]++;
            while (cnt[s[j]] &gt; 1) cnt[s[i++]]--;
            ans = max(ans, j - i + 1);
        }
        return ans;
    }
};
Copy<br><br>Note that since the non-shrinkable window might include multiple duplicates, we need to add a variable to our state.<br>
<br>state:&nbsp;dup&nbsp;is the number of different kinds of characters that has duplicate in the window. For example, if window contains&nbsp;aabbc, then&nbsp;dup = 2&nbsp;because&nbsp;a&nbsp;and&nbsp;b&nbsp;has duplicates.
<br>invalid:&nbsp;dup &gt; 0&nbsp;is invalid
<br>// OJ: https://leetcode.com/problems/longest-substring-without-repeating-characters/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int i = 0, j = 0, N = s.size(), cnt[128] = {}, dup = 0;
        for (; j &lt; N; ++j) {
            dup += ++cnt[s[j]] == 2;
            if (dup) dup -= --cnt[s[i++]] == 1;
        }
        return j - i;
    }
};
Copy<br><br><br>
<br>state:&nbsp;prod&nbsp;is the product of the numbers in window
<br>invalid:&nbsp;prod &gt;= k&nbsp;is invalid.
<br>Note that since we want to make sure the window&nbsp;[i, j]&nbsp;is valid at the end of the&nbsp;for&nbsp;loop, we need&nbsp;i &lt;= j&nbsp;check for the inner&nbsp;for&nbsp;loop.&nbsp;i == j + 1&nbsp;means this window is empty.<br>Each maximum window&nbsp;[i, j]&nbsp;can generate&nbsp;j - i + 1&nbsp;valid subarrays, so we need to add&nbsp;j - i + 1&nbsp;to the answer.<br>// OJ: https://leetcode.com/problems/subarray-product-less-than-k/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
public:
    int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; A, int k) {
        if (k == 0) return 0;
        long i = 0, j = 0, N = A.size(), prod = 1, ans = 0;
        for (; j &lt; N; ++j) {
            prod *= A[j];
            while (i &lt;= j &amp;&amp; prod &gt;= k) prod /= A[i++];
            ans += j - i + 1;
        }
        return ans;
    }
};
Copy<br>The non-shrinkable template is not applicable here since we need to the length of each maximum window ending at each position<br><br>Below is my original answer during contest. As you can see, if I don't use this template, the solution could be a bit complex.<br><br>Let two pointers&nbsp;i, j&nbsp;form a window&nbsp;[i, j]. The window is valid if&nbsp;(j - i + 1) * A[j] - sum &lt;= k.<br>We keep increasing&nbsp;j&nbsp;to expand the window as much as possible. When the window becomes invalid, we increment&nbsp;i.<br>// OJ: https://leetcode.com/problems/frequency-of-the-most-frequent-element/
// Author: github.com/lzl124631x
// Time: O(NlogN)
// Space: O(1)
class Solution {
public:
    int maxFrequency(vector&lt;int&gt;&amp; A, int k) {
        sort(begin(A), end(A));
        long i = 0, j = 0, N = A.size(), ans = 1, sum = A[0];
        for (; i &lt; N; ++i) {
            while (j &lt; N &amp;&amp; (j - i + 1) * A[j] - sum &lt;= k) {
                ans = max(ans, j - i + 1);
                ++j;
                if (j &lt; N) sum += A[j];
            }
            sum -= A[i];
        }
        return ans;
    }
};
Copy<br>Its really a wonderful blog and if we could have some practice problems attached with it , then it would have been awesome .<br>
After studying your cheat-sheet I was able to solve this problem&nbsp;<a rel="noopener" class="external-link" href="https://leetcode.com/problems/max-consecutive-ones-iii/" target="_blank">https://leetcode.com/problems/max-consecutive-ones-iii/</a><br>Mar 13, 2022<br>More Questions :<br>
<a rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank">https://leetcode.com/problems/minimum-size-subarray-sum/</a><br>
<a rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-window-substring/" target="_blank">https://leetcode.com/problems/minimum-window-substring/</a>]]></description><link>codepattern/blog/code/c++-maximum-sliding-window-cheatsheet-template!.html</link><guid isPermaLink="false">CodePattern/blog/code/C++ Maximum Sliding Window Cheatsheet Template!.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[C++ O(N) Time Sliding Window + "At Most to Equal" trick]]></title><description><![CDATA[ 
 <br><br>// OJ: https://leetcode.com/problems/count-vowel-substrings-of-a-string/
// Author: github.com/lzl124631x
// Time: O(N^2)
// Space: O(1)
class Solution {
    bool isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    };
public:
    int countVowelSubstrings(string s) {
        int ans = 0, N = s.size();
        unordered_map&lt;char, int&gt; cnt;
        for (int i = 0; i &lt; N; ++i) {
            cnt.clear();
            for (int j = i; j &lt; N &amp;&amp; isVowel(s[j]); ++j) {
                cnt[s[j]]++;
                if (cnt.size() == 5) ++ans;
            }
        }
        return ans;
    }
};
Copy<br><br>Check out "<a data-href="C++ Maximum Sliding Window Cheatsheet Template!" href="codepattern/blog/code/c++-maximum-sliding-window-cheatsheet-template!.html" class="internal-link" target="_self" rel="noopener">C++ Maximum Sliding Window Cheatsheet Template!</a>"<br>Function&nbsp;atMost(s, goal)&nbsp;returns the number of substrings that has at most&nbsp;goal&nbsp;number of unique vowels. The answer is&nbsp;atMost(s, 5) - atMost(s, 4).<br>// OJ: https://leetcode.com/problems/count-vowel-substrings-of-a-string/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
    bool isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    };
    int atMost(string &amp;s, int goal) {
        int ans = 0, i = 0, j = 0, N = s.size();
        unordered_map&lt;char, int&gt; cnt;
        for (; j &lt; N; ++j) {
            if (!isVowel(s[j])) {
                i = j + 1;
                cnt.clear();
                continue;
            }
            cnt[s[j]]++;
            for (; cnt.size() &gt; goal; ++i) {
                if (--cnt[s[i]] == 0) cnt.erase(s[i]);
            }
            ans += j - i + 1; // this window [i, j] is the maximum window ending at `s[j]` that has at most `goal` number of unique vowels.
        }
        return ans;
    }
public:
    int countVowelSubstrings(string s) {
        return atMost(s, 5) - atMost(s, 4);
    }
};
Copy<br>🌟 Sliding Window "At Most to Equal" trick<br><br><br>NOTE: this is an extension to my "<a data-tooltip-position="top" aria-label="https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!" rel="noopener" class="external-link" href="https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!" target="_blank">C++ Maximum Sliding Window Cheatsheet Template!</a>". Please make sure you are familiar with this template first.<br>For problems solvable using this trick, also check out "<a data-tooltip-position="top" aria-label="https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!" rel="noopener" class="external-link" href="https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!" target="_blank">C++ Maximum Sliding Window Cheatsheet Template!</a>"<br>For a find maximum sliding window problem that is looking for windows with&nbsp;exactly&nbsp;k&nbsp;something in it, we can convert it to a problem that is looking for&nbsp;at most&nbsp;k&nbsp;something in it.<br>It's because "number of windows with&nbsp;exactly&nbsp;k&nbsp;something in it" = "number of windows with&nbsp;at most&nbsp;k&nbsp;something in it" - "number of windows with&nbsp;at most&nbsp;k - 1&nbsp;something in it".<br>Take&nbsp;<a data-tooltip-position="top" aria-label="https://leetcode.com/problems/binary-subarrays-with-sum/discuss/1513935/C%2B%2B-Prefix-State-Map-or-Sliding-Window" rel="noopener" class="external-link" href="https://leetcode.com/problems/binary-subarrays-with-sum/discuss/1513935/C%2B%2B-Prefix-State-Map-or-Sliding-Window" target="_blank">930. Binary Subarrays With Sum (Medium)</a>&nbsp;for example, if we want to use the "find maximum sliding window template" without this trick, we would need to use 3 pointers --&nbsp;i&nbsp;as the left edge of the window with&nbsp;goal&nbsp;number of&nbsp;1s in it,&nbsp;j&nbsp;as the left edge of the window with&nbsp;goal - 1&nbsp;number of&nbsp;1s in it, and&nbsp;k&nbsp;as the right edge.<br>// OJ: https://leetcode.com/problems/binary-subarrays-with-sum/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
public:
    int numSubarraysWithSum(vector&lt;int&gt;&amp; A, int goal) {
        int i = 0, j = 0, k = 0, N = A.size(), sum1 = 0, sum2 = 0, ans = 0;
        for (; k &lt; N; ++k) {
            sum1 += A[k];
            sum2 += A[k];
            while (i &lt;= k &amp;&amp; sum1 &gt; goal) sum1 -= A[i++];
            while (j &lt;= k &amp;&amp; sum2 &gt; goal - 1) sum2 -= A[j++];
            ans += j - i;
        }
        return ans;
    }
};
Copy<br>This code is repetitive -- we need to do similar jobs for&nbsp;i&nbsp;and&nbsp;j, and keep states for both windows.<br>By extracting an&nbsp;atMost&nbsp;function, we make the code cleaner and less error-prone.<br>// OJ: https://leetcode.com/problems/binary-subarrays-with-sum/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
    int atMost(vector&lt;int&gt; &amp;A, int goal) {
        int i = 0, j = 0, N = A.size(), sum = 0, ans = 0;
        for (; j &lt; N; ++j) {
            sum += A[j];
            while (i &lt;= j &amp;&amp; sum &gt; goal) sum -= A[i++];
            ans += j - i;
        }
        return ans;
    }
public:
    int numSubarraysWithSum(vector&lt;int&gt;&amp; A, int goal) {
        return atMost(A, goal) - atMost(A, goal - 1);
    }
};
Copy]]></description><link>codepattern/blog/code/c++-o(n)-time-sliding-window-+-&quot;at-most-to-equal&quot;-trick.html</link><guid isPermaLink="false">CodePattern/blog/code/C++ O(N) Time Sliding Window + &quot;At Most to Equal&quot; trick.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[Patterns]]></title><description><![CDATA[ 
 <br><br><br>
<br><a data-href="#Minimum (Maximum) Path to Reach a Target" href="about:blank#Minimum_(Maximum)_Path_to_Reach_a_Target" class="internal-link" target="_self" rel="noopener">Minimum (Maximum) Path to Reach a Target</a>
<br><a data-href="#Distinct Ways" href="about:blank#Distinct_Ways" class="internal-link" target="_self" rel="noopener">Distinct Ways</a>
<br><a data-href="#Merging Intervals" href="about:blank#Merging_Intervals" class="internal-link" target="_self" rel="noopener">Merging Intervals</a>
<br><a data-href="Dynamic Programming Patterns#DP on Strings" href="codepattern/blog/dynamic-programming-patterns.html#DP_on_Strings" class="internal-link" target="_self" rel="noopener">Dynamic Programming Patterns &gt; DP on Strings</a>
<br><a data-href="#Decision Making" href="about:blank#Decision_Making" class="internal-link" target="_self" rel="noopener">Decision Making</a>
<br><br>Problem list:&nbsp;<a rel="noopener" class="external-link" href="https://leetcode.com/list/55ac4kuc" target="_blank">https://leetcode.com/list/55ac4kuc</a><br>Generate problem statement for this pattern<br><br>
Given a target find minimum (maximum) cost / path / sum to reach the target.
<br><br>
Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state.
<br>routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]
Copy<br>Generate optimal solutions for all values in the target and return the value for the target.<br><br>for (int j = 0; j &lt; ways.size(); ++j) {
    result = min(result, topDown(target - ways[j]) + cost/ path / sum);
}
return memo[/*state parameters*/] = result;
Copy<br><br>for (int i = 1; i &lt;= target; ++i) {
   for (int j = 0; j &lt; ways.size(); ++j) {
       if (ways[j] &lt;= i) {
           dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ;
       }
   }
}
 
return dp[target]
Copy<br><br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/min-cost-climbing-stairs/" rel="noopener" class="external-link" href="https://leetcode.com/problems/min-cost-climbing-stairs/" target="_blank">746. Min Cost Climbing Stairs</a>&nbsp;Easy<br><br>int result = min(minCost(n-1, cost, memo), minCost(n-2, cost, memo)) + (n == cost.size() ? 0 : cost[n]);
return memo[n] = result;
Copy<br><br>for (int i = 2; i &lt;= n; ++i) {
   dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i]);
}
 
return dp[n]
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/minimum-path-sum/" rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-path-sum/" target="_blank">64. Minimum Path Sum</a>&nbsp;Medium<br><br>int result = min(pathSum(i+1, j, grid, memo), pathSum(i, j+1, grid, memo)) + grid[i][j];
    
return memo[i][j] = result;
Copy<br><br>for (int i = 1; i &lt; n; ++i) {
   for (int j = 1; j &lt; m; ++j) {
       grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j];
   }
}
 
return grid[n-1][m-1]
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/coin-change/" rel="noopener" class="external-link" href="https://leetcode.com/problems/coin-change/" target="_blank">322. Coin Change</a>&nbsp;Medium<br><br>for (int i = 0; i &lt; coins.size(); ++i) {
    if (coins[i] &lt;= target) { // check validity of a sub-problem
        result = min(ans, CoinChange(target - coins[i], coins) + 1);
    }
}
return memo[target] = result;
Copy<br><br>for (int j = 1; j &lt;= amount; ++j) {
   for (int i = 0; i &lt; coins.size(); ++i) {
       if (coins[i] &lt;= j) {
           dp[j] = min(dp[j], dp[j - coins[i]] + 1);
       }
   }
}
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/minimum-falling-path-sum/" rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-falling-path-sum/" target="_blank">931. Minimum Falling Path Sum</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/minimum-cost-for-tickets/" rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-cost-for-tickets/" target="_blank">983. Minimum Cost For Tickets</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/2-keys-keyboard/" rel="noopener" class="external-link" href="https://leetcode.com/problems/2-keys-keyboard/" target="_blank">650. 2 Keys Keyboard</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/perfect-squares/" rel="noopener" class="external-link" href="https://leetcode.com/problems/perfect-squares/" target="_blank">279. Perfect Squares</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/last-stone-weight-ii/" rel="noopener" class="external-link" href="https://leetcode.com/problems/last-stone-weight-ii/" target="_blank">1049. Last Stone Weight II</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/triangle/" rel="noopener" class="external-link" href="https://leetcode.com/problems/triangle/" target="_blank">120. Triangle</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/ones-and-zeroes/" rel="noopener" class="external-link" href="https://leetcode.com/problems/ones-and-zeroes/" target="_blank">474. Ones and Zeroes</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/maximal-square/" rel="noopener" class="external-link" href="https://leetcode.com/problems/maximal-square/" target="_blank">221. Maximal Square</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/coin-change/" rel="noopener" class="external-link" href="https://leetcode.com/problems/coin-change/" target="_blank">322. Coin Change</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/" rel="noopener" class="external-link" href="https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/" target="_blank">1240. Tiling a Rectangle with the Fewest Squares</a>&nbsp;Hard<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/dungeon-game/" rel="noopener" class="external-link" href="https://leetcode.com/problems/dungeon-game/" target="_blank">174. Dungeon Game</a>&nbsp;Hard<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/minimum-number-of-refueling-stops/" rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-number-of-refueling-stops/" target="_blank">871. Minimum Number of Refueling Stops</a>&nbsp;Hard<br><br><br>Problem List:&nbsp;<a rel="noopener" class="external-link" href="https://leetcode.com/list/55ajm50i" target="_blank">https://leetcode.com/list/55ajm50i</a><br>Generate problem statement for this pattern<br><br>
Given a target find a number of distinct ways to reach the target.
<br><br>
Sum all possible ways to reach the current state.
<br>routes[i] = routes[i-1] + routes[i-2], ... , + routes[i-k]
Copy<br>Generate sum for all values in the target and return the value for the target.<br><br>for (int j = 0; j &lt; ways.size(); ++j) {
    result += topDown(target - ways[j]);
}
return memo[/*state parameters*/] = result;
Copy<br><br>for (int i = 1; i &lt;= target; ++i) {
   for (int j = 0; j &lt; ways.size(); ++j) {
       if (ways[j] &lt;= i) {
           dp[i] += dp[i - ways[j]];
       }
   }
}
 
return dp[target]
Copy<br><br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/climbing-stairs/" rel="noopener" class="external-link" href="https://leetcode.com/problems/climbing-stairs/" target="_blank">70. Climbing Stairs</a>&nbsp;Easy<br><br>int result = climbStairs(n-1, memo) + climbStairs(n-2, memo); 
    
return memo[n] = result;
Copy<br><br>for (int stair = 2; stair &lt;= n; ++stair) {
   for (int step = 1; step &lt;= 2; ++step) {
       dp[stair] += dp[stair-step];   
   }
}
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/unique-paths/" rel="noopener" class="external-link" href="https://leetcode.com/problems/unique-paths/" target="_blank">62. Unique Paths</a>&nbsp;Medium<br><br>int result = UniquePaths(x-1, y) + UniquePaths(x, y-1);

return memo[x][y] = result;
Copy<br><br>for (int i = 1; i &lt; m; ++i) {
   for (int j = 1; j &lt; n; ++j) {
       dp[i][j] = dp[i][j-1] + dp[i-1][j];
   }
}
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/" rel="noopener" class="external-link" href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/" target="_blank">1155. Number of Dice Rolls With Target Sum</a>&nbsp;Medium<br>for (int rep = 1; rep &lt;= d; ++rep) {
   vector&lt;int&gt; new_ways(target+1);
   for (int already = 0; already &lt;= target; ++already) {
       for (int pipe = 1; pipe &lt;= f; ++pipe) {
           if (already - pipe &gt;= 0) {
               new_ways[already] += ways[already - pipe];
               new_ways[already] %= mod;
           }
       }
   }
   ways = new_ways;
}
Copy<br>Note<br>Some questions point out the number of repetitions, in that case, add one more loop to simulate every repetition.<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/knight-probability-in-chessboard/" rel="noopener" class="external-link" href="https://leetcode.com/problems/knight-probability-in-chessboard/" target="_blank">688. Knight Probability in Chessboard</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/target-sum/" rel="noopener" class="external-link" href="https://leetcode.com/problems/target-sum/" target="_blank">494. Target Sum</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/combination-sum-iv/" rel="noopener" class="external-link" href="https://leetcode.com/problems/combination-sum-iv/" target="_blank">377. Combination Sum IV</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/knight-dialer/" rel="noopener" class="external-link" href="https://leetcode.com/problems/knight-dialer/" target="_blank">935. Knight Dialer</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/dice-roll-simulation/" rel="noopener" class="external-link" href="https://leetcode.com/problems/dice-roll-simulation/" target="_blank">1223. Dice Roll Simulation</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/partition-equal-subset-sum/" rel="noopener" class="external-link" href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank">416. Partition Equal Subset Sum</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/soup-servings/" rel="noopener" class="external-link" href="https://leetcode.com/problems/soup-servings/" target="_blank">808. Soup Servings</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/domino-and-tromino-tiling/" rel="noopener" class="external-link" href="https://leetcode.com/problems/domino-and-tromino-tiling/" target="_blank">790. Domino and Tromino Tiling</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/" rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/" target="_blank">801. Minimum Swaps To Make Sequences Increasing</a><br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/number-of-longest-increasing-subsequence/" rel="noopener" class="external-link" href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/" target="_blank">673. Number of Longest Increasing Subsequence</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/unique-paths-ii/" rel="noopener" class="external-link" href="https://leetcode.com/problems/unique-paths-ii/" target="_blank">63. Unique Paths II</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/out-of-boundary-paths/" rel="noopener" class="external-link" href="https://leetcode.com/problems/out-of-boundary-paths/" target="_blank">576. Out of Boundary Paths</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" rel="noopener" class="external-link" href="https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank">1269. Number of Ways to Stay in the Same Place After Some Steps</a>&nbsp;Hard<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/count-vowels-permutation/" rel="noopener" class="external-link" href="https://leetcode.com/problems/count-vowels-permutation/" target="_blank">1220. Count Vowels Permutation</a>&nbsp;Hard<br><br><br>Problem List:&nbsp;<a rel="noopener" class="external-link" href="https://leetcode.com/list/55aj8s16" target="_blank">https://leetcode.com/list/55aj8s16</a><br>Generate problem statement for this pattern<br><br>
Given a set of numbers find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.
<br><br>
Find all optimal solutions for every interval and return the best possible answer.
<br>// from i to j
dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]
Copy<br>Get the best from the left and right sides and add a solution for the current position.<br><br>for (int k = i; k &lt;= j; ++k) {
    result = max(result, topDown(nums, i, k-1) + result[k] + topDown(nums, k+1, j));
}
return memo[/*state parameters*/] = result;
Copy<br><br>for(int l = 1; l&lt;n; l++) {
   for(int i = 0; i&lt;n-l; i++) {
       int j = i+l;
       for(int k = i; k&lt;j; k++) {
           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);
       }
   }
}
 
return dp[0][n-1];
Copy<br>for(int l = 1; l&lt;n; l++) {
   for(int i = 0; i&lt;n-l; i++) {
       int j = i+l;
       for(int k = i; k&lt;j; k++) {
           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);
       }
   }
}
 
return dp[0][n-1]
Copy<br><br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/" rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/" target="_blank">1130. Minimum Cost Tree From Leaf Values</a>&nbsp;Medium<br>for (int l = 1; l &lt; n; ++l) {
   for (int i = 0; i &lt; n - l; ++i) {
       int j = i + l;
       dp[i][j] = INT_MAX;
       for (int k = i; k &lt; j; ++k) {
           dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j]);
       }
   }
}
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/unique-binary-search-trees/" rel="noopener" class="external-link" href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank">96. Unique Binary Search Trees</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/minimum-score-triangulation-of-polygon/" rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-score-triangulation-of-polygon/" target="_blank">1039. Minimum Score Triangulation of Polygon</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/remove-boxes/" rel="noopener" class="external-link" href="https://leetcode.com/problems/remove-boxes/" target="_blank">546. Remove Boxes</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/minimum-cost-to-merge-stones/" rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-cost-to-merge-stones/" target="_blank">1000. Minimum Cost to Merge Stones</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/burst-balloons/" rel="noopener" class="external-link" href="https://leetcode.com/problems/burst-balloons/" target="_blank">312. Burst Balloons</a>&nbsp;Hard<br><br>for (int k = i; k &lt;= j; ++k) {
    result = max(result, topDown(nums, i, k-1, memo) + (i-1 &gt;= 0 ? nums[i-1] : 1) * nums[k] * (j+1 &lt; nums.size() ? nums[j+1] : 1) + topDown(nums, k+1, j, memo));
}
return memo[i][j] = result;
Copy<br><br>for(int l = 1; l &lt; n; l++) {
    for(int i = 0; i &lt; n-l; i++) {
        int j = i+l;
        for(int k = i; k &lt;= j; k++) {
            dp[i][j] = max(dp[i][j], (((k&gt;i &amp;&amp; k&gt;0) ? dp[i][k-1] : 0) + (i&gt;0 ? nums[i-1] : 1) * nums[k] * (j&lt;n-1 ? nums[j+1] : 1) + ((k&lt;j &amp;&amp; k&lt;n-1) ? dp[k+1][j] : 0)));
        }
    }
}
return dp[0][n-1];
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/guess-number-higher-or-lower-ii/" rel="noopener" class="external-link" href="https://leetcode.com/problems/guess-number-higher-or-lower-ii/" target="_blank">375. Guess Number Higher or Lower II</a>&nbsp;Medium<br><br><br>Problem List:&nbsp;<a rel="noopener" class="external-link" href="https://leetcode.com/list/55afh7m7" target="_blank">https://leetcode.com/list/55afh7m7</a><br>General problem statement for this pattern can vary but most of the time you are given two strings where lengths of those strings are not big<br><br>
Given two strings&nbsp;s1&nbsp;and&nbsp;s2, return&nbsp;some result.
<br><br>
Most of the problems on this pattern requires a solution that can be accepted in O(n^2) complexity.
<br>// i - indexing string s1
// j - indexing string s2
for (int i = 1; i &lt;= n; ++i) {
   for (int j = 1; j &lt;= m; ++j) {
       if (s1[i-1] == s2[j-1]) {
           dp[i][j] = /*code*/;
       } else {
           dp[i][j] = /*code*/;
       }
   }
}
Copy<br>
If you are given one string&nbsp;s&nbsp;the approach may little vary
<br>for (int l = 1; l &lt; n; ++l) {
   for (int i = 0; i &lt; n-l; ++i) {
       int j = i + l;
       if (s[i] == s[j]) {
           dp[i][j] = /*code*/;
       } else {
           dp[i][j] = /*code*/;
       }
   }
}
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/longest-common-subsequence/" rel="noopener" class="external-link" href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank">1143. Longest Common Subsequence</a>&nbsp;Medium<br>for (int i = 1; i &lt;= n; ++i) {
   for (int j = 1; j &lt;= m; ++j) {
       if (text1[i-1] == text2[j-1]) {
           dp[i][j] = dp[i-1][j-1] + 1;
       } else {
           dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
       }
   }
}
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/palindromic-substrings/" rel="noopener" class="external-link" href="https://leetcode.com/problems/palindromic-substrings/" target="_blank">647. Palindromic Substrings</a>&nbsp;Medium<br>for (int l = 1; l &lt; n; ++l) {
   for (int i = 0; i &lt; n-l; ++i) {
       int j = i + l;
       if (s[i] == s[j] &amp;&amp; dp[i+1][j-1] == j-i-1) {
           dp[i][j] = dp[i+1][j-1] + 2;
       } else {
           dp[i][j] = 0;
       }
   }
}
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/longest-palindromic-subsequence/" rel="noopener" class="external-link" href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank">516. Longest Palindromic Subsequence</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/shortest-common-supersequence/" rel="noopener" class="external-link" href="https://leetcode.com/problems/shortest-common-supersequence/" target="_blank">1092. Shortest Common Supersequence</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/edit-distance/" rel="noopener" class="external-link" href="https://leetcode.com/problems/edit-distance/" target="_blank">72. Edit Distance</a>&nbsp;Hard<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/distinct-subsequences/" rel="noopener" class="external-link" href="https://leetcode.com/problems/distinct-subsequences/" target="_blank">115. Distinct Subsequences</a>&nbsp;Hard<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/" rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank">712. Minimum ASCII Delete Sum for Two Strings</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/longest-palindromic-substring/" rel="noopener" class="external-link" href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank">5. Longest Palindromic Substring</a>&nbsp;Medium<br><br><br>Problem List:&nbsp;<a rel="noopener" class="external-link" href="https://leetcode.com/list/55af7bu7" target="_blank">https://leetcode.com/list/55af7bu7</a><br>The general problem statement for this pattern is forgiven situation decide whether to use or not to use the current state. So, the problem requires you to make a decision at a current state.<br><br>
Given a set of values find an answer with an option to choose or ignore the current value.
<br><br>
If you decide to choose the current value use the previous result where the value was ignored; vice-versa, if you decide to ignore the current value use previous result where value was used.
<br>// i - indexing a set of values
// j - options to ignore j values
for (int i = 1; i &lt; n; ++i) {
   for (int j = 1; j &lt;= k; ++j) {
       dp[i][j] = max({dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]});
       dp[i][j-1] = max({dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]});
   }
}
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/house-robber/" rel="noopener" class="external-link" href="https://leetcode.com/problems/house-robber/" target="_blank">198. House Robber</a>&nbsp;Easy<br>for (int i = 1; i &lt; n; ++i) {
   dp[i][1] = max(dp[i-1][0] + nums[i], dp[i-1][1]);
   dp[i][0] = dp[i-1][1];
}
Copy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" rel="noopener" class="external-link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank">121. Best Time to Buy and Sell Stock</a>&nbsp;Easy<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" rel="noopener" class="external-link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank">714. Best Time to Buy and Sell Stock with Transaction Fee</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" rel="noopener" class="external-link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank">309. Best Time to Buy and Sell Stock with Cooldown</a>&nbsp;Medium<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" rel="noopener" class="external-link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank">123. Best Time to Buy and Sell Stock III</a>&nbsp;Hard<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" rel="noopener" class="external-link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank">188. Best Time to Buy and Sell Stock IV</a>&nbsp;Hard<br>I hope these tips will be helpful 😊<br>interview-tipsproblem-statementdynamic-programming]]></description><link>codepattern/blog/dynamic-programming-patterns.html</link><guid isPermaLink="false">CodePattern/blog/Dynamic Programming Patterns.md</guid><pubDate>Tue, 11 Jun 2024 18:18:15 GMT</pubDate></item><item><title><![CDATA[3. Longest Substring Without Repeating Characters]]></title><description><![CDATA[ 
 <br><br>Given a string&nbsp;s, find the length of the&nbsp;longest&nbsp;<br>substring<br>&nbsp;without repeating characters.<br>Example 1:<br>Input: s = "abcabcbb"<br>
Output: 3<br>
Explanation: The answer is "abc", with the length of 3.<br>Example 2:<br>Input: s = "bbbbb"<br>
Output: 1<br>
Explanation: The answer is "b", with the length of 1.<br>Example 3:<br>Input: s = "pwwkew"<br>
Output: 3<br>
Explanation: The answer is "wke", with the length of 3.<br>
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.<br>Constraints:<br>
<br>0 &lt;= s.length &lt;= 5 * 104
<br>s&nbsp;consists of English letters, digits, symbols and spaces.
<br><br>class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s=="") return 0;
        int mx=-1,ans=0,l=0,r=0;
        unordered_map&lt;char, int&gt; m;
        int count = 0;
        for(;r&lt;s.length();r++){
            m[s[r]]++;
            count += m[s[r]]==1;

            for(;(r-l+1)!=count;l++){
                m[s[l]]--;
                count -= m[s[l]]==0;
            }

            mx = max(mx, r-l+1);
        }
        return mx;
    }
};
Copy]]></description><link>codepattern/code/problems/3.-longest-substring-without-repeating-characters.html</link><guid isPermaLink="false">CodePattern/code/problems/3. Longest Substring Without Repeating Characters.md</guid><pubDate>Mon, 10 Jun 2024 08:46:30 GMT</pubDate></item><item><title><![CDATA[5. Longest Palindromic Substring]]></title><description><![CDATA[ 
 <br><br>Given a string s, return the longest<br>
palindromic substring in s.<br>Example 1:<br>
Input: s = "babad"<br>
Output: "bab"<br>
Explanation: "aba" is also a valid answer.<br>Example 2:<br>
Input: s = "cbbd"<br>
Output: "bb"<br>Constraints:<br>
1 &lt;= s.length &lt;= 1000<br>
s consist of only digits and English letters.<br><br>class Solution {
public:

    string longestPalindrome(string s) {
        int start=0, mx=0;
        int l,r;
        int n=s.length();

        for(int i=0;i&lt;n;i++){
        // ODD Palidrom
            l=r=i;
            while(l&gt;=0&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r]){
                if(r-l+1&gt;mx){
                    start=l;
                    mx = r-l+1;
                }
                l--;r++;
            }

			// EVEN Plaidrome
            l=i,r=i+1;
            while(l&gt;=0&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r]){
                if(r-l+1&gt;mx){
                    start=l;
                    mx = r-l+1;
                }
                l--;r++;
            }
        }   
        return s.substr(start,mx);
    }
};
Copy]]></description><link>codepattern/code/problems/5.-longest-palindromic-substring.html</link><guid isPermaLink="false">CodePattern/code/problems/5. Longest Palindromic Substring.md</guid><pubDate>Tue, 11 Jun 2024 11:22:09 GMT</pubDate></item><item><title><![CDATA[48. Rotate Image]]></title><description><![CDATA[ 
 <br>You are given an&nbsp;n x n&nbsp;2D&nbsp;matrix&nbsp;representing an image, rotate the image by&nbsp;90&nbsp;degrees (clockwise).<br>You have to rotate the image&nbsp;<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank"><strong></strong></a>in-place, which means you have to modify the input 2D matrix directly.&nbsp;DO NOT&nbsp;allocate another 2D matrix and do the rotation.<br>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" referrerpolicy="no-referrer"><br>Input: matrix = <a data-href="1,2,3],[4,5,6],[7,8,9" href="1,2,3],[4,5,6],[7,8,9" class="internal-link" target="_self" rel="noopener">1,2,3],[4,5,6],[7,8,9</a><br>
Output: <a data-href="7,4,1],[8,5,2],[9,6,3" href="7,4,1],[8,5,2],[9,6,3" class="internal-link" target="_self" rel="noopener">7,4,1],[8,5,2],[9,6,3</a><br>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" referrerpolicy="no-referrer"><br>Input: matrix = <a data-href="5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16" href="5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16" class="internal-link" target="_self" rel="noopener">5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16</a><br>
Output: <a data-href="15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11" href="15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11" class="internal-link" target="_self" rel="noopener">15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11</a><br>Constraints:<br>
<br>n == matrix.length == matrix[i].length
<br>1 &lt;= n &lt;= 20
<br>-1000 &lt;= matrix[i][j] &lt;= 1000
<br>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        
        // Step 1: Transpose the matrix
        for (int i = 0; i &lt; n; ++i) {
            for (int j = i + 1; j &lt; n; ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        
        // Step 2: Reverse each row
        for (int i = 0; i &lt; n; ++i) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};

Copy]]></description><link>codepattern/code/problems/48.-rotate-image.html</link><guid isPermaLink="false">CodePattern/code/problems/48. Rotate Image.md</guid><pubDate>Tue, 11 Jun 2024 16:59:32 GMT</pubDate><enclosure url="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[53. Maximum Subarray]]></title><description><![CDATA[ 
 <br>Given an integer array&nbsp;nums, find the subarray with the largest sum, and return&nbsp;its sum.<br>Example 1:<br>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>
Output: 6<br>
Explanation: The subarray [4,-1,2,1] has the largest sum 6.<br>Example 2:<br>Input: nums = [1]<br>
Output: 1<br>
Explanation: The subarray [1] has the largest sum 1.<br>Example 3:<br>Input: nums = [5,4,-1,7,8]<br>
Output: 23<br>
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.<br>Constraints:<br>
<br>1 &lt;= nums.length &lt;= 105
<br>-104 &lt;= nums[i] &lt;= 104
<br>Follow up:&nbsp;If you have figured out the&nbsp;O(n)&nbsp;solution, try coding another solution using the&nbsp;divide and conquer&nbsp;approach, which is more subtle.<br><br>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int mx=0, ans=INT_MIN;

        for(int &amp;i:nums){
            mx = max(i, mx+i);
            ans = max(mx, ans);
        }

        return ans;
    }
};
Copy]]></description><link>codepattern/code/problems/53.-maximum-subarray.html</link><guid isPermaLink="false">CodePattern/code/problems/53. Maximum Subarray.md</guid><pubDate>Tue, 11 Jun 2024 17:03:55 GMT</pubDate></item><item><title><![CDATA[76. Minimum Window Substring]]></title><description><![CDATA[ 
 <br><a rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank">https://leetcode.com/problems/minimum-window-substring/description/</a>]]></description><link>codepattern/code/problems/76.-minimum-window-substring.html</link><guid isPermaLink="false">CodePattern/code/problems/76. Minimum Window Substring.md</guid><pubDate>Wed, 12 Jun 2024 19:13:13 GMT</pubDate></item><item><title><![CDATA[Problem]]></title><description><![CDATA[ 
 <br><br>Given a binary array&nbsp;nums&nbsp;and an integer&nbsp;goal, return&nbsp;the number of non-empty&nbsp;subarrays&nbsp;with a sum&nbsp;goal.<br>A&nbsp;subarray&nbsp;is a contiguous part of the array.<br>Example 1:<br>Input: nums = [1,0,1,0,1], goal = 2<br>
Output: 4<br>
Explanation: The 4 subarrays are bolded and underlined below:<br>
[1,0,1,0,1]<br>
[1,0,1,0,1]<br>
[1,0,1,0,1]<br>
[1,0,1,0,1]<br>Example 2:<br>Input: nums = [0,0,0,0,0], goal = 0<br>
Output: 15<br>Constraints:<br>
<br>1 &lt;= nums.length &lt;= 3 * 104
<br>nums[i]&nbsp;is either&nbsp;0&nbsp;or&nbsp;1.
<br>0 &lt;= goal &lt;= nums.length
<br><br>class Solution {
public:
    int atMost(vector&lt;int&gt;&amp; nums, int goal){
    int i=0,j=0,sum=0,out=0, N=nums.size();

        while(j&lt;N){
            out+=nums[j++];
            for(;(out&gt;goal)&amp;&amp;(i&lt;j);i++){
                out-=nums[i];
            }
            sum+=j-i;
        }

        return sum;
    }
    int numSubarraysWithSum(vector&lt;int&gt;&amp; nums, int goal) {
        return atMost(nums, goal) - atMost(nums, goal-1);
    }
};
Copy<br><br>
<br><a data-href="🌟 Sliding Window &quot;At Most to Equal&quot; trick" href="codepattern/code/template/🌟-sliding-window-&quot;at-most-to-equal&quot;-trick.html" class="internal-link" target="_self" rel="noopener">🌟 Sliding Window "At Most to Equal" trick</a>
<br><a data-href="Sliding Window" href="codepattern/code/template/sliding-window.html" class="internal-link" target="_self" rel="noopener">Sliding Window</a>
]]></description><link>codepattern/code/problems/930.-binary-subarrays-with-sum.html</link><guid isPermaLink="false">CodePattern/code/problems/930. Binary Subarrays With Sum.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[945. Minimum Increment to Make Array Unique]]></title><description><![CDATA[ 
 <br><a rel="noopener" class="external-link" href="https://leetcode.com/problems/minimum-increment-to-make-array-unique/description/" target="_blank">https://leetcode.com/problems/minimum-increment-to-make-array-unique/description/</a>]]></description><link>codepattern/code/problems/945.-minimum-increment-to-make-array-unique.html</link><guid isPermaLink="false">CodePattern/code/problems/945. Minimum Increment to Make Array Unique.md</guid><pubDate>Fri, 14 Jun 2024 02:32:00 GMT</pubDate></item><item><title><![CDATA[Problem]]></title><description><![CDATA[ 
 <br><br>Given an integer array&nbsp;nums&nbsp;and an integer&nbsp;k, return&nbsp;the number of&nbsp;good subarrays&nbsp;of&nbsp;nums.<br>A&nbsp;good array&nbsp;is an array where the number of different integers in that array is exactly&nbsp;k.<br>
<br>For example,&nbsp;[1,2,3,1,2]&nbsp;has&nbsp;3&nbsp;different integers:&nbsp;1,&nbsp;2, and&nbsp;3.
<br>A&nbsp;subarray&nbsp;is a&nbsp;contiguous&nbsp;part of an array.<br>Example 1:<br>Input: nums = [1,2,1,2,3], k = 2<br>
Output: 7<br>
Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]<br>Example 2:<br>Input: nums = [1,2,1,3,4], k = 3<br>
Output: 3<br>
Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].<br>Constraints:<br>
<br>1 &lt;= nums.length &lt;= 2 * 104
<br>1 &lt;= nums[i], k &lt;= nums.length
<br><br>class Solution {
public:
    int atMost(vector&lt;int&gt;&amp; nums, int k) {
        int N=nums.size(),j=0,i=0,sum=0,count=0;
        unordered_map&lt;int,int&gt; m;
        while(j&lt;N){
            if(m[nums[j]]==0){
                count++;
            }
            m[nums[j]]++;
            j++;
       
            while(count&gt;k&amp;&amp;i&lt;j){
                m[nums[i]]--;
                if(m[nums[i]]==0){
                count--;
                }
                i++;
            }

            sum+=(j-i);
        }
        return sum;
    }

       int subarraysWithKDistinct(vector&lt;int&gt;&amp; nums, int k) {
            return atMost(nums,k)-atMost(nums,k-1);
       }
};
Copy]]></description><link>codepattern/code/problems/992.-subarrays-with-k-different-integers.html</link><guid isPermaLink="false">CodePattern/code/problems/992. Subarrays with K Different Integers.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[1248. Count Number of Nice Subarrays]]></title><description><![CDATA[ 
 <br>Given an array of integers&nbsp;nums&nbsp;and an integer&nbsp;k. A continuous subarray is called&nbsp;nice&nbsp;if there are&nbsp;k&nbsp;odd numbers on it.<br>Return&nbsp;the number of&nbsp;nice&nbsp;sub-arrays.<br>Example 1:<br>Input: nums = [1,1,2,1,1], k = 3<br>
Output: 2<br>
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].<br>Example 2:<br>Input: nums = [2,4,6], k = 1<br>
Output: 0<br>
Explanation: There is no odd numbers in the array.<br>Example 3:<br>Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2<br>
Output: 16<br>Constraints:<br>
<br>1 &lt;= nums.length &lt;= 50000
<br>1 &lt;= nums[i] &lt;= 10^5
<br>1 &lt;= k &lt;= nums.length
<br><br>class Solution {
public:
    int atMost(vector&lt;int&gt;&amp; nums, int k) {
        int l=0,r=0,N=nums.size(),count=0,ans=0;

        for(r=0;r&lt;N;r++){
            count += nums[r]&amp;1;

            for(;count&gt;k;l++) count -= nums[l]&amp;1;

            ans += r-l;
        
        }

        return ans;
    }

    int numberOfSubarrays(vector&lt;int&gt;&amp; nums, int k) {
        return atMost(nums, k) - atMost(nums, k-1);
        
    }
};
Copy]]></description><link>codepattern/code/problems/1248.-count-number-of-nice-subarrays.html</link><guid isPermaLink="false">CodePattern/code/problems/1248. Count Number of Nice Subarrays.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[Problem]]></title><description><![CDATA[ 
 <br><br>Given a binary array&nbsp;nums, you should delete one element from it.<br>Return&nbsp;the size of the longest non-empty subarray containing only&nbsp;1's in the resulting array. Return&nbsp;0&nbsp;if there is no such subarray.<br>Example 1:<br>Input: nums = [1,1,0,1]<br>
Output: 3<br>
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.<br>Example 2:<br>Input: nums = [0,1,1,1,0,1,1,0,1]<br>
Output: 5<br>
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].<br>Example 3:<br>Input: nums = [1,1,1]<br>
Output: 2<br>
Explanation: You must delete one element.<br>Constraints:<br>
<br>1 &lt;= nums.length &lt;= 105
<br>nums[i]&nbsp;is either&nbsp;0&nbsp;or&nbsp;1.
<br><br>“asfas.cpp” could not be found.]]></description><link>codepattern/code/problems/1493.-longest-subarray-of-1&apos;s-after-deleting-one-element.html</link><guid isPermaLink="false">CodePattern/code/problems/1493. Longest Subarray of 1&apos;s After Deleting One Element.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[Problem]]></title><description><![CDATA[ 
 <br><br>Given an array&nbsp;arr[ ]&nbsp;of size&nbsp;N&nbsp;having&nbsp;elements, the&nbsp;task is to find the next greater element for each element of the array in order of their appearance in the array.<br>
Next greater element of an element in the array is the nearest element on the right which is greater than the current element.<br>
If there does not exist next greater of current element, then next greater element for current element is -1. For example, next greater of the last element is always -1.<br>Example 1:<br>Input:<br>
N = 4, arr[] = [1 3 2 4]<br>
Output:<br>
3 4 4 -1<br>
Explanation:<br>
In the array, the next larger element<br>
to 1 is 3 , 3 is 4 , 2 is 4 and for 4 ?<br>
since it doesn't exist, it is -1.<br>Example 2:<br>Input:<br>
N = 5, arr[] [6 8 0 1 3]<br>
Output:<br>
8 -1 1 3 -1<br>
Explanation:<br>
In the array, the next larger element to<br>
6 is 8, for 8 there is no larger elements<br>
hence it is -1, for 0 it is 1 , for 1 it<br>
is 3 and then for 3 there is no larger<br>
element on right and hence -1.<br>Your Task:<br>
This is a&nbsp;function&nbsp;problem. You only need to complete the function&nbsp;nextLargerElement()&nbsp;that takes list of integers&nbsp;arr[ ]&nbsp;and&nbsp;N&nbsp;as input parameters&nbsp;and returns list of integers&nbsp;of length N&nbsp;denoting the next greater elements for all the corresponding elements in the input array.<br>Expected Time Complexity&nbsp;: O(N)<br>
Expected Auxiliary Space&nbsp;: O(N)<br>Constraints:<br>
1 ≤ N ≤&nbsp;106<br>
0 ≤&nbsp;Ai&nbsp;≤&nbsp;1018<br><br>     vector&lt;long long&gt; nextLargerElement(vector&lt;long long&gt;&amp; nums,int n) {

        stack&lt;long long&gt; s;
        vector&lt;long long&gt; v(n, -1);

        for(int i=n-1;i&gt;=0;i--){
            while(!s.empty() &amp;&amp; s.top()&lt;=nums[i]){
                s.pop();
            }
            
            if (!s.empty()) {
                v[i] = s.top();
            }
     

            s.push(nums[i]);
        }

        return v;
    }
Copy]]></description><link>codepattern/code/problems/next-greater-element.html</link><guid isPermaLink="false">CodePattern/code/problems/Next Greater Element.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[Problem]]></title><description><![CDATA[ 
 <br><br>Given an array&nbsp;a&nbsp;of integers of length&nbsp;n, find the nearest smaller number for every element such that the smaller element is on left side.If no small element present on the left print -1.<br>Example 1:<br>Input: n = 3<br>
a = {1, 6, 2}<br>
Output: -1 1 1<br>
Explaination: There is no number at the<br>
left of 1. Smaller number than 6 and 2 is 1.<br>Example 2:<br>Input: n = 6<br>
a = {1, 5, 0, 3, 4, 5}<br>
Output: -1 1 -1 0 3 4<br>
Explaination: Upto 3 it is easy to see<br>
the smaller numbers. But for 4 the smaller<br>
numbers are 1, 0 and 3. But among them 3<br>
is closest. Similary for 5 it is 4.<br>Your Task:<br>
You do not need to read input or print anything. Your task is to complete the function&nbsp;leftSmaller()&nbsp;which takes n and a as input parameters and returns the list of smaller numbers.<br>Expected Time Complexity:&nbsp;O(n)<br>
Expected Auxiliary Space:&nbsp;O(n)<br>Constraints:<br>
1 ≤ n ≤ 10000<br>
0 ≤ a[i] ≤ 104<br><br>vector&lt;int&gt; leftSmaller(int n, int a[]){
        stack&lt;int&gt; s;
        vector&lt;int&gt; v(n,-1);
	    
	    for(int i=0;i&lt;n;i++){
	        while(!s.empty()&amp;&amp;s.top()&gt;=a[i]) s.pop();
	        if(!s.empty()) v[i] = s.top();
	        s.push(a[i]);
	    }
	    
	    return v;
    }
Copy<br>Gemini
The provided C++ code efficiently addresses the problem of finding the nearest smaller number for each element in an array, ensuring that the smaller number is on the left. It utilizes a stack data structure and operates in a single pass through the array.
Approach:

<br>Stack for Storing Elements: A stack is used to store elements from the array.
<br>Loop Through the Array: Iterate through each element in the array.
<br>Pop Elements Smaller Than the Current Element: While the stack is not empty and the top element is greater than or equal to the current element, pop the top element from the stack.
<br>Nearest Smaller Element: If the stack is not empty, the top element represents the nearest smaller number for the current element.
<br>Push Current Element: Push the current element onto the stack.
<br>Populate the Result Vector: Store the nearest smaller number for each element in a vector. If no smaller number is found, assign -1 to that element.

Complexity Analysis:

<br>Time Complexity: O(N), where N is the number of elements in the array. A single pass through the array is performed, and each element is processed only once.
<br>Space Complexity: O(N), as the stack and the result vector can both store up to N elements in the worst case.

Example Usage:
int main() {
  int n = 6;
  int a[] = {1, 5, 0, 3, 4, 5};
  vector&lt;int&gt; result = leftSmaller(n, a);
  for (int x : result) cout &lt;&lt; x &lt;&lt; " ";
   return 0;
 }
Copy
<br>&gt; 
&gt; **Output:**
&gt; 
&gt; ```
&gt; -1 1 -1 0 3 4
&gt; ```
 
Copy]]></description><link>codepattern/code/problems/smallest-number-on-left.html</link><guid isPermaLink="false">CodePattern/code/problems/Smallest number on left.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[Problem]]></title><description><![CDATA[ 
 <br><br>The stock span problem is a financial problem where we have a series of&nbsp;n&nbsp;daily price quotes for a stock and we need to calculate the span of stocks price for all&nbsp;n&nbsp;days.&nbsp;<br>
The span&nbsp;Si&nbsp;of the stocks price on a given day&nbsp;i&nbsp;is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the given day is less than or equal to its price on the current day.<br>
For example, if an array of 7 days prices is given as {100, 80, 60, 70, 60, 75, 85}, then the span values for corresponding 7 days are {1, 1, 1, 2, 1, 4, 6}.<br>Example 1:<br>Input:<br>
N = 7, price[] = [100 80 60 70 60 75 85]<br>
Output:<br>
1 1 1 2 1 4 6<br>
Explanation:<br>
Traversing the given input span<br>
100 is greater than equal to 100 and there are no more elements behind it so the span is 1,<br>
80 is greater than equal to 80 and smaller than 100 so the span is 1,<br>
60 is greater than equal to 60 and smaller than 80 so the span is 1,<br>
70 is greater than equal to 60,70 and smaller than 80 so the span is 2,<br>
60 is greater than equal to 60 and smaller than 70 so the span is 1,<br>
75 is greater than equal to 60,70,60,75 and smaller than 100 so the span is 4,<br>
85 is greater than equal to 80,60,70,60,75,85 and smaller than 100 so the span is 6.<br>
Hence the output will be 1 1 1 2 1 4 6.<br>Example 2:<br>Input:<br>
N = 6, price[] = [10 4 5 90 120 80]<br>
Output:<br>
1 1 2 4 5 1<br>
Explanation:<br>
Traversing the given input span<br>
10 is greater than equal to 10 and there are no more elements behind it so the span is 1,<br>
4 is greater than equal to 4 and smaller than 10 so the span is 1,<br>
5 is greater than equal to 4,5 and smaller than 10 so the span is 2,<br>
90 is greater than equal to all previous elements so the span is 4,<br>
120 is greater than equal to all previous elements so the span is 5,<br>
80 is greater than equal to 80 and smaller than 120 so the span is 1,<br>
Hence the output will be 1 1 2 4 5 1.  <br>User Task:<br>
The task is to complete the function&nbsp;calculateSpan() which takes two parameters, an array&nbsp;price[]&nbsp;denoting the price of stocks, and an integer&nbsp;N&nbsp;denoting the size of the array and number of days. This function finds the span of stock's price for all N&nbsp;days and returns an array of length&nbsp;N&nbsp;denoting the span for the i-th day.<br>Expected Time Complexity:&nbsp;O(N).<br>
Expected Auxiliary Space:&nbsp;O(N).<br>Constraints:<br>
1 ≤ N ≤ 105<br>
1 ≤ C[i] ≤ 105<br><img src="https://contribute.geeksforgeeks.org/wp-content/uploads/Stock_span.png" referrerpolicy="no-referrer"><br><br> vector &lt;int&gt; calculateSpan(int price[], int n)
    {
        stack&lt;int&gt; s;
        vector&lt;int&gt; v(n, 1);
       for(int i=0;i&lt;n;i++){
           while(!s.empty() &amp;&amp; price[s.top()]&lt;=price[i]) s.pop();
           if(!s.empty()) v[i] = i-s.top();
           else v[i] = i+1;
           s.push(i);
       }
       return v;
    }
Copy]]></description><link>codepattern/code/problems/stock-span-problem.html</link><guid isPermaLink="false">CodePattern/code/problems/Stock span problem.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate><enclosure url="https://contribute.geeksforgeeks.org/wp-content/uploads/Stock_span.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://contribute.geeksforgeeks.org/wp-content/uploads/Stock_span.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Unique Paths]]></title><description><![CDATA[ 
 <br><a rel="noopener" class="external-link" href="https://leetcode.com/problems/unique-paths/submissions/1285559964/" target="_blank">https://leetcode.com/problems/unique-paths/submissions/1285559964/</a>]]></description><link>codepattern/code/problems/unique-paths.html</link><guid isPermaLink="false">CodePattern/code/problems/Unique Paths.md</guid><pubDate>Wed, 12 Jun 2024 04:52:34 GMT</pubDate></item><item><title><![CDATA[🌟 Sliding Window "At Most to Equal" trick]]></title><description><![CDATA[ 
 <br>NOTE: this is an extension to my "<a data-tooltip-position="top" aria-label="https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!" rel="noopener" class="external-link" href="https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!" target="_blank">C++ Maximum Sliding Window Cheatsheet Template!</a>". Please make sure you are familiar with this template first.<br>For problems solvable using this trick, also check out "<a data-tooltip-position="top" aria-label="https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!" rel="noopener" class="external-link" href="https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!" target="_blank">C++ Maximum Sliding Window Cheatsheet Template!</a>"<br>For a find maximum sliding window problem that is looking for windows with&nbsp;exactly&nbsp;k&nbsp;something in it, we can convert it to a problem that is looking for&nbsp;at most&nbsp;k&nbsp;something in it.<br>It's because "number of windows with&nbsp;exactly&nbsp;k&nbsp;something in it" = "number of windows with&nbsp;at most&nbsp;k&nbsp;something in it" - "number of windows with&nbsp;at most&nbsp;k - 1&nbsp;something in it".<br>Take&nbsp;<a data-tooltip-position="top" aria-label="https://leetcode.com/problems/binary-subarrays-with-sum/discuss/1513935/C%2B%2B-Prefix-State-Map-or-Sliding-Window" rel="noopener" class="external-link" href="https://leetcode.com/problems/binary-subarrays-with-sum/discuss/1513935/C%2B%2B-Prefix-State-Map-or-Sliding-Window" target="_blank">930. Binary Subarrays With Sum (Medium)</a>&nbsp;for example, if we want to use the "find maximum sliding window template" without this trick, we would need to use 3 pointers --&nbsp;i&nbsp;as the left edge of the window with&nbsp;goal&nbsp;number of&nbsp;1s in it,&nbsp;j&nbsp;as the left edge of the window with&nbsp;goal - 1&nbsp;number of&nbsp;1s in it, and&nbsp;k&nbsp;as the right edge.<br>// OJ: https://leetcode.com/problems/binary-subarrays-with-sum/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
public:
    int numSubarraysWithSum(vector&lt;int&gt;&amp; A, int goal) {
        int i = 0, j = 0, k = 0, N = A.size(), sum1 = 0, sum2 = 0, ans = 0;
        for (; k &lt; N; ++k) {
            sum1 += A[k];
            sum2 += A[k];
            while (i &lt;= k &amp;&amp; sum1 &gt; goal) sum1 -= A[i++];
            while (j &lt;= k &amp;&amp; sum2 &gt; goal - 1) sum2 -= A[j++];
            ans += j - i;
        }
        return ans;
    }
};
Copy<br>This code is repetitive -- we need to do similar jobs for&nbsp;i&nbsp;and&nbsp;j, and keep states for both windows.<br>By extracting an&nbsp;atMost&nbsp;function, we make the code cleaner and less error-prone.<br>// OJ: https://leetcode.com/problems/binary-subarrays-with-sum/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
    int atMost(vector&lt;int&gt; &amp;A, int goal) {
        int i = 0, j = 0, N = A.size(), sum = 0, ans = 0;
        for (; j &lt; N; ++j) {
            sum += A[j];
            while (i &lt;= j &amp;&amp; sum &gt; goal) sum -= A[i++];
            ans += j - i;
        }
        return ans;
    }
public:
    int numSubarraysWithSum(vector&lt;int&gt;&amp; A, int goal) {
        return atMost(A, goal) - atMost(A, goal - 1);
    }
};
Copy]]></description><link>codepattern/code/template/🌟-sliding-window-&quot;at-most-to-equal&quot;-trick.html</link><guid isPermaLink="false">CodePattern/code/template/🌟 Sliding Window &quot;At Most to Equal&quot; trick.md</guid><pubDate>Mon, 10 Jun 2024 08:36:45 GMT</pubDate></item><item><title><![CDATA[Io Optimization]]></title><description><![CDATA[ 
 <br>// The following block might trivially improve the exec time.
static const auto __optimize__ = []() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(NULL);
    return 0;
}();
Copy]]></description><link>codepattern/code/template/io-optimization.html</link><guid isPermaLink="false">CodePattern/code/template/Io Optimization.md</guid><pubDate>Mon, 10 Jun 2024 08:36:43 GMT</pubDate></item><item><title><![CDATA[LCS Bottom UP]]></title><description><![CDATA[ 
 <br><br>Sure, here are the equations for the different cases in the Longest Common Subsequence (LCS) problem:<br>
<br>
Base Case:

<br>
<br>


<br>
Recursive Case:<br>
 

<br>    for (int i = 1; i &lt;= m; ++i) {
        for (int j = 1; j &lt;= n; ++j) {
            if (X[i - 1] == Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
Copy<br><br>To reconstruct the LCS from the filled DP table, follow these steps and use the corresponding equations:<br>
<br>
Initialization:

<br>Start from the bottom-right corner of the DP table:<br>



<br>
Reconstruction Loop:

<br>While i &gt; 0 and j &gt; 0:

<br>If the characters match:


<br>If the characters do not match:

<br>Move in the direction of the maximum value:<br>
<br>







<br>    int i = m, j = n;
    while (i &gt; 0 &amp;&amp; j &gt; 0) {
        // If current character in X and Y are same, then it is part of LCS
        if (X[i - 1] == Y[j - 1]) {
            lcs[--index] = X[i - 1]; // Put current character in result
            --i;
            --j;
        }
        // If not the same, find the larger of two and go in the direction of the larger value
        else if (dp[i - 1][j] &gt; dp[i][j - 1]) {
            --i;
        } else {
            --j;
        }
    }
Copy]]></description><link>codepattern/code/template/lcs-bottom-up.html</link><guid isPermaLink="false">CodePattern/code/template/LCS Bottom UP.md</guid><pubDate>Mon, 10 Jun 2024 18:21:27 GMT</pubDate></item><item><title><![CDATA[Sliding Window (Shrinkable)]]></title><description><![CDATA[ 
 <br><br>int i = 0, j = 0, ans = 0;
for (; j &lt; N; ++j) {
    // CODE: use A[j] to update state which might make the window invalid
    for (; invalid(); ++i) { // when invalid, keep shrinking the left edge until it's valid again
        // CODE: update state using A[i]
    }
    ans = max(ans, j - i + 1); // the window [i, j] is the maximum window we've found thus far
}
return ans;
Copy<br>Gemini
The provided code demonstrates the sliding window algorithm that iterates through an array using two pointers, i and j, to find the maximum window with a valid state. It follows a "shrinkable" approach, where the window can shrink as long as it remains valid.

<br>
Initialize Pointers and Maximum Length:

<br>i is the left edge of the sliding window, initially set to 0.
<br>j is the right edge of the sliding window, initially set to 0.
<br>ans stores the maximum length of a valid window found so far, initialized to 0.


<br>
Iterate and Check Validity:

<br>For each element A[j], check if the current window [i, j] is valid.
<br>If invalid:

<br>Increment i until the window becomes valid again, updating the state using A[i] as the left edge.




<br>
Update Maximum Length:

<br>After checking validity, calculate the length of the current window as j - i + 1.
<br>Update ans to be the maximum of its current value and the current window length.


<br>
Advance Right Pointer:

<br>Increment j to continue iterating and potentially expand the window.


<br>
Return Result:

<br>After iterating through the entire array, ans holds the maximum length of a valid window found during the process. This value is returned as the result.



In summary, this code efficiently finds the maximum window with a valid state in an array by shrinking the left edge as necessary while expanding the right edge.
]]></description><link>codepattern/code/template/sliding-window.html</link><guid isPermaLink="false">CodePattern/code/template/Sliding Window.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[Stack]]></title><description><![CDATA[ 
 <br><br><br>Given an array&nbsp;arr[ ]&nbsp;of size&nbsp;N&nbsp;having&nbsp;elements, the&nbsp;task is to find the next greater element for each element of the array in order of their appearance in the array.<br>
Next greater element of an element in the array is the nearest element on the right which is greater than the current element.<br>
If there does not exist next greater of current element, then next greater element for current element is -1. For example, next greater of the last element is always -1.<br>Example 1:<br>Input:<br>
N = 4, arr[] = [1 3 2 4]<br>
Output:<br>
3 4 4 -1<br>
Explanation:<br>
In the array, the next larger element<br>
to 1 is 3 , 3 is 4 , 2 is 4 and for 4 ?<br>
since it doesn't exist, it is -1.<br>Example 2:<br>Input:<br>
N = 5, arr[] [6 8 0 1 3]<br>
Output:<br>
8 -1 1 3 -1<br>
Explanation:<br>
In the array, the next larger element to<br>
6 is 8, for 8 there is no larger elements<br>
hence it is -1, for 0 it is 1 , for 1 it<br>
is 3 and then for 3 there is no larger<br>
element on right and hence -1.<br>Your Task:<br>
This is a&nbsp;function&nbsp;problem. You only need to complete the function&nbsp;nextLargerElement()&nbsp;that takes list of integers&nbsp;arr[ ]&nbsp;and&nbsp;N&nbsp;as input parameters&nbsp;and returns list of integers&nbsp;of length N&nbsp;denoting the next greater elements for all the corresponding elements in the input array.<br>Expected Time Complexity&nbsp;: O(N)<br>
Expected Auxiliary Space&nbsp;: O(N)<br>Constraints:<br>
1 ≤ N ≤&nbsp;106<br>
0 ≤&nbsp;Ai&nbsp;≤&nbsp;1018<br><br>     vector&lt;long long&gt; nextLargerElement(vector&lt;long long&gt;&amp; nums,int n) {

        stack&lt;long long&gt; s;
        vector&lt;long long&gt; v(n, -1);

        for(int i=n-1;i&gt;=0;i--){
            while(!s.empty() &amp;&amp; s.top()&lt;=nums[i]){
                s.pop();
            }
            
            if (!s.empty()) {
                v[i] = s.top();
            }
     

            s.push(nums[i]);
        }

        return v;
    }
CopyNext Greater Element<br><br><br>The stock span problem is a financial problem where we have a series of&nbsp;n&nbsp;daily price quotes for a stock and we need to calculate the span of stocks price for all&nbsp;n&nbsp;days.&nbsp;<br>
The span&nbsp;Si&nbsp;of the stocks price on a given day&nbsp;i&nbsp;is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the given day is less than or equal to its price on the current day.<br>
For example, if an array of 7 days prices is given as {100, 80, 60, 70, 60, 75, 85}, then the span values for corresponding 7 days are {1, 1, 1, 2, 1, 4, 6}.<br>Example 1:<br>Input:<br>
N = 7, price[] = [100 80 60 70 60 75 85]<br>
Output:<br>
1 1 1 2 1 4 6<br>
Explanation:<br>
Traversing the given input span<br>
100 is greater than equal to 100 and there are no more elements behind it so the span is 1,<br>
80 is greater than equal to 80 and smaller than 100 so the span is 1,<br>
60 is greater than equal to 60 and smaller than 80 so the span is 1,<br>
70 is greater than equal to 60,70 and smaller than 80 so the span is 2,<br>
60 is greater than equal to 60 and smaller than 70 so the span is 1,<br>
75 is greater than equal to 60,70,60,75 and smaller than 100 so the span is 4,<br>
85 is greater than equal to 80,60,70,60,75,85 and smaller than 100 so the span is 6.<br>
Hence the output will be 1 1 1 2 1 4 6.<br>Example 2:<br>Input:<br>
N = 6, price[] = [10 4 5 90 120 80]<br>
Output:<br>
1 1 2 4 5 1<br>
Explanation:<br>
Traversing the given input span<br>
10 is greater than equal to 10 and there are no more elements behind it so the span is 1,<br>
4 is greater than equal to 4 and smaller than 10 so the span is 1,<br>
5 is greater than equal to 4,5 and smaller than 10 so the span is 2,<br>
90 is greater than equal to all previous elements so the span is 4,<br>
120 is greater than equal to all previous elements so the span is 5,<br>
80 is greater than equal to 80 and smaller than 120 so the span is 1,<br>
Hence the output will be 1 1 2 4 5 1.  <br>User Task:<br>
The task is to complete the function&nbsp;calculateSpan() which takes two parameters, an array&nbsp;price[]&nbsp;denoting the price of stocks, and an integer&nbsp;N&nbsp;denoting the size of the array and number of days. This function finds the span of stock's price for all N&nbsp;days and returns an array of length&nbsp;N&nbsp;denoting the span for the i-th day.<br>Expected Time Complexity:&nbsp;O(N).<br>
Expected Auxiliary Space:&nbsp;O(N).<br>Constraints:<br>
1 ≤ N ≤ 105<br>
1 ≤ C[i] ≤ 105<br><img src="https://contribute.geeksforgeeks.org/wp-content/uploads/Stock_span.png" referrerpolicy="no-referrer"><br><br> vector &lt;int&gt; calculateSpan(int price[], int n)
    {
        stack&lt;int&gt; s;
        vector&lt;int&gt; v(n, 1);
       for(int i=0;i&lt;n;i++){
           while(!s.empty() &amp;&amp; price[s.top()]&lt;=price[i]) s.pop();
           if(!s.empty()) v[i] = i-s.top();
           else v[i] = i+1;
           s.push(i);
       }
       return v;
    }
CopyStock span problem<br><br><br>Given an array&nbsp;a&nbsp;of integers of length&nbsp;n, find the nearest smaller number for every element such that the smaller element is on left side.If no small element present on the left print -1.<br>Example 1:<br>Input: n = 3<br>
a = {1, 6, 2}<br>
Output: -1 1 1<br>
Explaination: There is no number at the<br>
left of 1. Smaller number than 6 and 2 is 1.<br>Example 2:<br>Input: n = 6<br>
a = {1, 5, 0, 3, 4, 5}<br>
Output: -1 1 -1 0 3 4<br>
Explaination: Upto 3 it is easy to see<br>
the smaller numbers. But for 4 the smaller<br>
numbers are 1, 0 and 3. But among them 3<br>
is closest. Similary for 5 it is 4.<br>Your Task:<br>
You do not need to read input or print anything. Your task is to complete the function&nbsp;leftSmaller()&nbsp;which takes n and a as input parameters and returns the list of smaller numbers.<br>Expected Time Complexity:&nbsp;O(n)<br>
Expected Auxiliary Space:&nbsp;O(n)<br>Constraints:<br>
1 ≤ n ≤ 10000<br>
0 ≤ a[i] ≤ 104<br><br>vector&lt;int&gt; leftSmaller(int n, int a[]){
        stack&lt;int&gt; s;
        vector&lt;int&gt; v(n,-1);
	    
	    for(int i=0;i&lt;n;i++){
	        while(!s.empty()&amp;&amp;s.top()&gt;=a[i]) s.pop();
	        if(!s.empty()) v[i] = s.top();
	        s.push(a[i]);
	    }
	    
	    return v;
    }
Copy<br>Gemini
The provided C++ code efficiently addresses the problem of finding the nearest smaller number for each element in an array, ensuring that the smaller number is on the left. It utilizes a stack data structure and operates in a single pass through the array.
Approach:

<br>Stack for Storing Elements: A stack is used to store elements from the array.
<br>Loop Through the Array: Iterate through each element in the array.
<br>Pop Elements Smaller Than the Current Element: While the stack is not empty and the top element is greater than or equal to the current element, pop the top element from the stack.
<br>Nearest Smaller Element: If the stack is not empty, the top element represents the nearest smaller number for the current element.
<br>Push Current Element: Push the current element onto the stack.
<br>Populate the Result Vector: Store the nearest smaller number for each element in a vector. If no smaller number is found, assign -1 to that element.

Complexity Analysis:

<br>Time Complexity: O(N), where N is the number of elements in the array. A single pass through the array is performed, and each element is processed only once.
<br>Space Complexity: O(N), as the stack and the result vector can both store up to N elements in the worst case.

Example Usage:
int main() {
  int n = 6;
  int a[] = {1, 5, 0, 3, 4, 5};
  vector&lt;int&gt; result = leftSmaller(n, a);
  for (int x : result) cout &lt;&lt; x &lt;&lt; " ";
   return 0;
 }
Copy
<br>&gt; 
&gt; **Output:**
&gt; 
&gt; ```
&gt; -1 1 -1 0 3 4
&gt; ```
 
CopySmallest number on left]]></description><link>codepattern/parent/stack/stack.html</link><guid isPermaLink="false">CodePattern/Parent/Stack/Stack.canvas</guid><pubDate>Mon, 03 Jun 2024 13:56:25 GMT</pubDate><enclosure url="https://contribute.geeksforgeeks.org/wp-content/uploads/Stock_span.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://contribute.geeksforgeeks.org/wp-content/uploads/Stock_span.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Stack Identification]]></title><description><![CDATA[ 
 <br>
<br>Array will be given
<br>time complexity will be  
<br>brute force solution will contains two dependent loops e.g.
<br>for(int i=0;i&lt;n;i++)
	for(int j=i;j&lt;n;j++)
	// OR
	for(int j=n;j&lt;i;j--)
	// OR
	for(int j=0;j&lt;i;j++)
	// OR
	for(int j=i;j&gt;0;j--)
Copy]]></description><link>codepattern/parent/stack/stack-identification.html</link><guid isPermaLink="false">CodePattern/Parent/Stack/Stack Identification.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate></item><item><title><![CDATA[Stack Questions List]]></title><description><![CDATA[ 
 <br><img alt="Pasted image 20240524174937.png" src="codepattern/parent/stack/media/pasted-image-20240524174937.png"><br>
<br><a data-href="Next Greater Element" href="codepattern/code/problems/next-greater-element.html" class="internal-link" target="_self" rel="noopener">Next Greater Element</a>
<br><a data-href="Smallest number on left" href="codepattern/code/problems/smallest-number-on-left.html" class="internal-link" target="_self" rel="noopener">Smallest number on left</a>
<br><a data-href="Stock span problem" href="codepattern/code/problems/stock-span-problem.html" class="internal-link" target="_self" rel="noopener">Stock span problem</a>
]]></description><link>codepattern/parent/stack/stack-questions-list.html</link><guid isPermaLink="false">CodePattern/Parent/Stack/Stack Questions List.md</guid><pubDate>Mon, 10 Jun 2024 08:35:49 GMT</pubDate><enclosure url="codepattern/parent/stack/media/pasted-image-20240524174937.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;codepattern/parent/stack/media/pasted-image-20240524174937.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[16.1 — Introduction to containers and arrays – Learn C++]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="16.1 — Introduction to containers and arrays – Learn C++.pdf > page=3&amp;selection=12,15,19,2&amp;color=yellow" data-href="16.1 — Introduction to containers and arrays – Learn C++.pdf#page=3&amp;selection=12,15,19,2&amp;color=yellow" href="course/learncpp/media/16.1-—-introduction-to-containers-and-arrays-–-learn-c++.pdf#page=3&amp;selection=12,15,19,2&amp;color=yellow" class="internal-link" target="_self" rel="noopener">Key Point</a>

 the number of elements in a container is often called it’s length (or sometimes count).

<br><a data-tooltip-position="top" aria-label="16.1 — Introduction to containers and arrays – Learn C++.pdf > page=3&amp;selection=57,12,59,59" data-href="16.1 — Introduction to containers and arrays – Learn C++.pdf#page=3&amp;selection=57,12,59,59" href="course/learncpp/media/16.1-—-introduction-to-containers-and-arrays-–-learn-c++.pdf#page=3&amp;selection=57,12,59,59" class="internal-link" target="_self" rel="noopener">Key Point</a>

 the term “length” when referring to the number of elements in a container, and use the term “size” to refer to amount of storage required by an object.

<br><br><a data-tooltip-position="top" aria-label="16.1 — Introduction to containers and arrays – Learn C++.pdf > page=4&amp;selection=12,46,17,45" data-href="16.1 — Introduction to containers and arrays – Learn C++.pdf#page=4&amp;selection=12,46,17,45" href="course/learncpp/media/16.1-—-introduction-to-containers-and-arrays-–-learn-c++.pdf#page=4&amp;selection=12,46,17,45" class="internal-link" target="_self" rel="noopener">Key Point</a>

 containers are homogenous, meaning the elements of a container are required to have the same type.

<br><a data-tooltip-position="top" aria-label="16.1 — Introduction to containers and arrays – Learn C++.pdf > page=4&amp;selection=42,0,52,8" data-href="16.1 — Introduction to containers and arrays – Learn C++.pdf#page=4&amp;selection=42,0,52,8" href="course/learncpp/media/16.1-—-introduction-to-containers-and-arrays-–-learn-c++.pdf#page=4&amp;selection=42,0,52,8" class="internal-link" target="_self" rel="noopener">Key Point</a>

The opposite of a homogenous container is a heterogenous container, which allows elements to be dierent types. Heterogeneous containers are typically supported by scripting languages (such as Python).

<br><br><a data-tooltip-position="top" aria-label="16.1 — Introduction to containers and arrays – Learn C++.pdf > page=4&amp;selection=91,0,101,17&amp;color=green" data-href="16.1 — Introduction to containers and arrays – Learn C++.pdf#page=4&amp;selection=91,0,101,17&amp;color=green" href="course/learncpp/media/16.1-—-introduction-to-containers-and-arrays-–-learn-c++.pdf#page=4&amp;selection=91,0,101,17&amp;color=green" class="internal-link" target="_self" rel="noopener">16.1 — Introduction to containers and arrays – Learn C++, p.4</a>

The following types are containers under the general programming denition, but are not considered to be containers by the C++ standard:<br>
C-style arrays 

<br>std::string 
<br>std::vector&lt;bool&gt;


<br><br><a data-tooltip-position="top" aria-label="16.1 — Introduction to containers and arrays – Learn C++.pdf > page=5&amp;selection=37,0,45,16" data-href="16.1 — Introduction to containers and arrays – Learn C++.pdf#page=5&amp;selection=37,0,45,16" href="course/learncpp/media/16.1-—-introduction-to-containers-and-arrays-–-learn-c++.pdf#page=5&amp;selection=37,0,45,16" class="internal-link" target="_self" rel="noopener">16.1 — Introduction to containers and arrays – Learn C++, p.5</a>

C++ contains three primary array types: (C-style) arrays, the std::vector container class, and the std::array container class.

<br><a data-tooltip-position="top" aria-label="16.1 — Introduction to containers and arrays – Learn C++.pdf > page=5&amp;selection=81,52,96,33" data-href="16.1 — Introduction to containers and arrays – Learn C++.pdf#page=5&amp;selection=81,52,96,33" href="course/learncpp/media/16.1-—-introduction-to-containers-and-arrays-–-learn-c++.pdf#page=5&amp;selection=81,52,96,33" class="internal-link" target="_self" rel="noopener">16.1 — Introduction to containers and arrays – Learn C++, p.5</a>

the std::vector container class was introduced in C++03. std::vector is the most exible of the three array types, and has a bunch of useful capabilities that the other array types don’t.

<br><a data-tooltip-position="top" aria-label="16.1 — Introduction to containers and arrays – Learn C++.pdf > page=5&amp;selection=98,9,102,83" data-href="16.1 — Introduction to containers and arrays – Learn C++.pdf#page=5&amp;selection=98,9,102,83" href="course/learncpp/media/16.1-—-introduction-to-containers-and-arrays-–-learn-c++.pdf#page=5&amp;selection=98,9,102,83" class="internal-link" target="_self" rel="noopener">16.1 — Introduction to containers and arrays – Learn C++, p.5</a>

the std::array container class was introduced in C++11 as a direct replacement for C-style arrays.

]]></description><link>course/learncpp/16.1-—-introduction-to-containers-and-arrays-–-learn-c++.html</link><guid isPermaLink="false">Course/LearnCPP/16.1 — Introduction to containers and arrays – Learn C++.md</guid><pubDate>Tue, 11 Jun 2024 05:39:05 GMT</pubDate></item><item><title><![CDATA[LearnCPP Introduction]]></title><description><![CDATA[ 
 <br><a data-href="16.1 — Introduction to containers and arrays – Learn C++" href="course/learncpp/16.1-—-introduction-to-containers-and-arrays-–-learn-c++.html" class="internal-link" target="_self" rel="noopener">16.1 — Introduction to containers and arrays – Learn C++</a>]]></description><link>course/learncpp/learncpp-introduction.html</link><guid isPermaLink="false">Course/LearnCPP/LearnCPP Introduction.md</guid><pubDate>Tue, 11 Jun 2024 04:55:33 GMT</pubDate></item><item><title><![CDATA[CS229 Introduction]]></title><description><![CDATA[ 
 <br>]]></description><link>course/stanford-cs229/cs229-introduction.html</link><guid isPermaLink="false">Course/Stanford CS229/CS229 Introduction.md</guid><pubDate>Thu, 06 Jun 2024 07:32:33 GMT</pubDate></item><item><title><![CDATA[Stanford CS229 - Machine Learning Course, Lecture 1 - Andrew Ng (Autumn 2018)]]></title><description><![CDATA[ 
 ]]></description><link>course/stanford-cs229/stanford-cs229-machine-learning-course,-lecture-1-andrew-ng-(autumn-2018).html</link><guid isPermaLink="false">Course/Stanford CS229/Stanford CS229 - Machine Learning Course, Lecture 1 - Andrew Ng (Autumn 2018).md</guid><pubDate>Thu, 06 Jun 2024 07:32:59 GMT</pubDate></item><item><title><![CDATA[M.Tech TimeTable & Syllabus]]></title><description><![CDATA[ 
 <br><img alt="Pasted image 20240610111805.png" src="lib/media/pasted-image-20240610111805.png">]]></description><link>syllabus/m.tech-timetable-&amp;-syllabus.html</link><guid isPermaLink="false">Syllabus/M.Tech TimeTable &amp; Syllabus.md</guid><pubDate>Mon, 10 Jun 2024 05:48:07 GMT</pubDate><enclosure url="lib/media/pasted-image-20240610111805.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/pasted-image-20240610111805.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Leetcode good at way]]></title><description><![CDATA[ 
 <br>
<br>Latex: for making report and assignments
<br>Basic Course of Machine Learning:

<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/playlist?list=PLoROMvodv4rMiGQp3WXShtMGgzqpfVfbU" rel="noopener" class="external-link" href="https://www.youtube.com/playlist?list=PLoROMvodv4rMiGQp3WXShtMGgzqpfVfbU" target="_blank">Stanford CS229: Machine Learning Full Course taught</a>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/playlist?list=PLEAYkSg4uSQ2If6TxjdzohtKIbelAKCCu" rel="noopener" class="external-link" href="https://www.youtube.com/playlist?list=PLEAYkSg4uSQ2If6TxjdzohtKIbelAKCCu" target="_blank">Pattern Recognition - PS Sastry | IISc - NPTEL</a>


<br>Discrete Mathematics &amp; Probababiliy
<br>Coding

<br>Follow any sheet or grind 150


<br><br>
<br>Pareto Problem set
]]></description><link>learning-about.html</link><guid isPermaLink="false">Learning About.md</guid><pubDate>Mon, 10 Jun 2024 06:43:00 GMT</pubDate></item><item><title><![CDATA[Course]]></title><description><![CDATA[ 
 <br><br>
<br>{code} Introduction: is introduction file use to keep track of progress of course, and this works as index or table content to the all the files connected to it
]]></description><link>rulebook.html</link><guid isPermaLink="false">RuleBook.md</guid><pubDate>Fri, 14 Jun 2024 09:48:37 GMT</pubDate></item></channel></rss>